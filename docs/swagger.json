{
    "schemes": [
        "http",
        "https"
    ],
    "swagger": "2.0",
    "info": {
        "description": "A REST API for podcast discovery and episode management.\nThis API provides endpoints for searching podcasts, managing episodes,\nand generating waveforms for audio visualization.",
        "title": "Podcast Player API",
        "contact": {
            "name": "Podcast Player API Support",
            "url": "https://github.com/killallgit/killallplayer-api",
            "email": "support@example.com"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "1.0"
    },
    "host": "localhost:9000",
    "basePath": "/",
    "paths": {
        "/": {
            "get": {
                "description": "Get version and basic information about the Podcast Player API",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "version"
                ],
                "summary": "Get API version",
                "responses": {
                    "200": {
                        "description": "API version information",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "description": {
                                    "type": "string"
                                },
                                "name": {
                                    "type": "string"
                                },
                                "status": {
                                    "type": "string"
                                },
                                "version": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/categories": {
            "get": {
                "description": "Get a list of all available podcast categories from the Podcast Index API",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "categories"
                ],
                "summary": "Get all podcast categories",
                "responses": {
                    "200": {
                        "description": "Categories response",
                        "schema": {
                            "$ref": "#/definitions/podcastindex.CategoriesResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "details": {
                                    "type": "string"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "status": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/clips": {
            "get": {
                "description": "Retrieve a paginated list of clips with optional filtering by label and processing status.\nResults are ordered by creation time (newest first). Use this endpoint to monitor clip processing\nor to browse available training data by label.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "clips"
                ],
                "summary": "List clips with optional filtering",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Filter clips by exact label match (e.g., 'advertisement')",
                        "name": "label",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "processing",
                            "ready",
                            "failed"
                        ],
                        "type": "string",
                        "description": "Filter by processing status",
                        "name": "status",
                        "in": "query"
                    },
                    {
                        "maximum": 1000,
                        "minimum": 1,
                        "type": "integer",
                        "default": 100,
                        "description": "Maximum number of clips to return (1-1000)",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "minimum": 0,
                        "type": "integer",
                        "default": 0,
                        "description": "Number of clips to skip for pagination",
                        "name": "offset",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of clips matching the filters",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/clips.ClipResponse"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Extract a labeled audio segment from a podcast episode for machine learning training datasets.\nThe clip will be automatically converted to 16kHz mono WAV format, padded or cropped to 15 seconds,\nand stored with the specified label. Processing is asynchronous - the clip status will be \"processing\"\ninitially and change to \"ready\" when extraction completes or \"failed\" if an error occurs.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "clips"
                ],
                "summary": "Create a new audio clip for ML training",
                "parameters": [
                    {
                        "description": "Audio clip extraction parameters with source URL and time range in seconds",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/clips.CreateClipRequest"
                        }
                    }
                ],
                "responses": {
                    "202": {
                        "description": "Clip creation accepted and processing started",
                        "schema": {
                            "$ref": "#/definitions/clips.ClipResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request parameters (e.g., end_time \u003c= start_time)",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error during clip creation",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/clips/export": {
            "get": {
                "description": "Export all clips with status \"ready\" as a ZIP archive for machine learning training.\nThe archive contains audio files organized by label directories and a JSONL manifest file\nwith metadata for each clip. Audio files are in 16kHz mono WAV format, suitable for\ntraining models like Whisper or Wav2Vec2. The manifest includes clip UUID, label, duration,\nsource URL, and original time range for full traceability.",
                "produces": [
                    "application/zip"
                ],
                "tags": [
                    "clips"
                ],
                "summary": "Export ML training dataset as ZIP",
                "responses": {
                    "200": {
                        "description": "ZIP archive containing labeled audio clips and manifest.jsonl",
                        "schema": {
                            "type": "file"
                        }
                    },
                    "500": {
                        "description": "Internal server error during export",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/clips/{uuid}": {
            "get": {
                "description": "Retrieve detailed information about a specific clip including its processing status,\naudio properties, and label. Check the 'status' field to determine if the clip is ready for use.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "clips"
                ],
                "summary": "Get clip details by UUID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Unique clip identifier (UUID format)",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Clip details retrieved successfully",
                        "schema": {
                            "$ref": "#/definitions/clips.ClipResponse"
                        }
                    },
                    "404": {
                        "description": "Clip with specified UUID not found",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            },
            "delete": {
                "description": "Permanently delete a clip from the database and remove its associated audio file from storage.\nThis operation cannot be undone. If the clip is already deleted, returns success (idempotent).",
                "tags": [
                    "clips"
                ],
                "summary": "Delete a clip and its audio file",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Unique clip identifier (UUID format)",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "204": {
                        "description": "Clip deleted successfully (no content returned)"
                    },
                    "400": {
                        "description": "Invalid UUID format",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error during deletion",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/clips/{uuid}/label": {
            "put": {
                "description": "Change the label of an existing clip to reorganize training datasets.\nThis operation moves the clip file to a new label directory in storage.\nLabels can be any string value for flexible categorization (e.g., \"advertisement\", \"music\", \"speech\").",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "clips"
                ],
                "summary": "Update a clip's label for re-categorization",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Unique clip identifier (UUID format)",
                        "name": "uuid",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "New label for categorization",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/clips.UpdateLabelRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Label updated successfully",
                        "schema": {
                            "$ref": "#/definitions/clips.ClipResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request (empty label or malformed JSON)",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Clip with specified UUID not found",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error or storage operation failed",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/episodes/{id}": {
            "get": {
                "description": "Retrieve comprehensive episode information including title, description, audio URL, duration,\nand links to additional resources like transcripts and chapters. The episode data is fetched\nfrom the local database cache or Podcast Index API if not cached. Audio URLs are direct links\nsuitable for streaming or download.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "episodes"
                ],
                "summary": "Get episode details by Podcast Index ID",
                "parameters": [
                    {
                        "minimum": 1,
                        "type": "integer",
                        "format": "int64",
                        "example": 16797088990,
                        "description": "Episode's Podcast Index ID (unique identifier from Podcast Index API)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Episode details including audio URL and metadata",
                        "schema": {
                            "$ref": "#/definitions/types.SingleEpisodeResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid ID format (must be positive integer)",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Episode not found in database or Podcast Index API",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error or API communication failure",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/episodes/{id}/clips": {
            "get": {
                "description": "Retrieve time-based clips for an episode. Clips can be used for auto-skipping commercials or\ncreating ML training datasets. If clips don't exist, analysis will be automatically queued\nand the response will include status:\"processing\". Poll this endpoint until status:\"ok\" to get clips.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "episodes"
                ],
                "summary": "Get clips/skip regions for an episode",
                "parameters": [
                    {
                        "minimum": 1,
                        "type": "integer",
                        "format": "int64",
                        "description": "Episode's Podcast Index ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Clips ready (status:ok)",
                        "schema": {
                            "$ref": "#/definitions/episodes.ClipsResponse"
                        }
                    },
                    "202": {
                        "description": "Analysis in progress (status:processing or queued)",
                        "schema": {
                            "$ref": "#/definitions/episodes.ClipsResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid episode ID format",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/episodes/{id}/reviews": {
            "get": {
                "description": "Fetch customer reviews from Apple Podcasts/iTunes for the podcast that contains this episode.\nReturns aggregated review data including total count, average rating, rating distribution,\nand individual reviews. Reviews can be sorted by recency or helpfulness. Note that not all\npodcasts have iTunes IDs, and some may have no reviews available.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "episodes"
                ],
                "summary": "Get iTunes reviews for episode's podcast",
                "parameters": [
                    {
                        "minimum": 1,
                        "type": "integer",
                        "format": "int64",
                        "description": "Episode's Podcast Index ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "enum": [
                            "mostrecent",
                            "mosthelpful"
                        ],
                        "type": "string",
                        "default": "mostrecent",
                        "description": "Sort order for reviews",
                        "name": "sort",
                        "in": "query"
                    },
                    {
                        "maximum": 10,
                        "minimum": 1,
                        "type": "integer",
                        "default": 1,
                        "description": "Page number for pagination (iTunes limits to 10 pages max)",
                        "name": "page",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Reviews data with aggregated statistics and individual reviews",
                        "schema": {
                            "$ref": "#/definitions/episodes.ReviewsResponse"
                        }
                    },
                    "404": {
                        "description": "Episode not found or podcast has no iTunes ID",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error or iTunes API failure",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/episodes/{id}/transcribe": {
            "get": {
                "description": "Retrieve the full transcription text for a podcast episode if available. Transcriptions may come\nfrom two sources: 'fetched' (downloaded from podcast RSS feed transcriptURL) or 'generated' (created\nusing Whisper speech-to-text). The response includes the full text, source type, language, and timestamps.\nUse POST /episodes/{id}/transcribe first to trigger generation if transcription doesn't exist.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "transcription"
                ],
                "summary": "Get episode transcription text",
                "parameters": [
                    {
                        "minimum": 1,
                        "type": "integer",
                        "format": "int64",
                        "description": "Episode's Podcast Index ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Full transcription text with metadata",
                        "schema": {
                            "$ref": "#/definitions/types.TranscriptionData"
                        }
                    },
                    "400": {
                        "description": "Invalid episode ID format",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "No transcription available for this episode",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Database or service error",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Trigger transcription for a podcast episode. The system first checks if a transcript is available\nat the episode's transcriptURL (from RSS feed). If found, it fetches and stores it. Otherwise, if\nWhisper is configured, it generates a transcription using speech-to-text. Transcription is an async\nprocess that may take several minutes depending on episode duration. Use the job_id to track progress.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "transcription"
                ],
                "summary": "Generate or fetch episode transcription",
                "parameters": [
                    {
                        "minimum": 1,
                        "type": "integer",
                        "format": "int64",
                        "description": "Episode's Podcast Index ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Transcription already exists (check 'source' field for origin)",
                        "schema": {
                            "$ref": "#/definitions/types.JobStatusResponse"
                        }
                    },
                    "202": {
                        "description": "Transcription job queued (includes job_id for tracking)",
                        "schema": {
                            "$ref": "#/definitions/types.JobStatusResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid episode ID format",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Service unavailable or configuration error",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/episodes/{id}/transcribe/status": {
            "get": {
                "description": "Check the status of transcription generation for an episode",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "transcription"
                ],
                "summary": "Get transcription generation status",
                "parameters": [
                    {
                        "type": "integer",
                        "format": "int64",
                        "description": "Episode ID (Podcast Index ID)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Transcription status",
                        "schema": {
                            "$ref": "#/definitions/types.JobStatusResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid Podcast Index Episode ID",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Transcription not available",
                        "schema": {
                            "$ref": "#/definitions/types.JobStatusResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/episodes/{id}/waveform": {
            "get": {
                "description": "Retrieve waveform data for audio visualization of a podcast episode. Waveform data consists of\namplitude values (0-1 range) sampled at regular intervals, suitable for rendering audio waveform\nvisualizations. If waveform doesn't exist, it will be automatically queued for generation and the\nresponse will include status:\"pending\" or \"processing\". Generation typically takes 10-60 seconds\ndepending on episode duration. Poll this endpoint until status:\"ready\" to get the final data.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "waveform"
                ],
                "summary": "Get audio waveform visualization data",
                "parameters": [
                    {
                        "minimum": 1,
                        "type": "integer",
                        "format": "int64",
                        "description": "Episode's Podcast Index ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Waveform ready with amplitude data array (status:ready)",
                        "schema": {
                            "$ref": "#/definitions/types.WaveformResponse"
                        }
                    },
                    "202": {
                        "description": "Generation in progress (status:processing or pending)",
                        "schema": {
                            "$ref": "#/definitions/types.WaveformResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid episode ID format",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Waveform service error or database failure",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "503": {
                        "description": "Generation failed, automatic retry scheduled (status:failed)",
                        "schema": {
                            "$ref": "#/definitions/types.WaveformResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/me": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Get current user information from Supabase JWT token",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Get current user",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/auth.UserInfo"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/podcasts/{id}/episodes": {
            "get": {
                "description": "Retrieve a list of episodes for a specific podcast using its Podcast Index ID (feedId).\nEpisodes are returned in reverse chronological order (newest first). This endpoint\nautomatically syncs with the Podcast Index API to ensure fresh data, then caches results.\nUse the podcast ID obtained from /search, /trending, or other podcast discovery endpoints.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "podcasts"
                ],
                "summary": "Get all episodes for a podcast",
                "parameters": [
                    {
                        "minimum": 1,
                        "type": "integer",
                        "format": "int64",
                        "example": 6780065,
                        "description": "Podcast's Podcast Index ID (feedId from search/trending results)",
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "maximum": 1000,
                        "minimum": 1,
                        "type": "integer",
                        "default": 20,
                        "description": "Maximum episodes to return. Higher values may increase response time",
                        "name": "max",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of episodes with full metadata including audio URLs",
                        "schema": {
                            "$ref": "#/definitions/types.EpisodesResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid podcast ID format or out of range",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to fetch episodes from Podcast Index API",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "503": {
                        "description": "Podcast Index API credentials not configured",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/random": {
            "get": {
                "description": "Returns random podcast episodes from Podcast Index",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Random"
                ],
                "summary": "Get random podcast episodes",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Number of episodes to return (default 10, max 100)",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Language code (default 'en')",
                        "name": "lang",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Comma-separated categories to exclude (e.g., 'News,Politics')",
                        "name": "notcat",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/models.EpisodeResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "description": {
                                    "type": "string"
                                },
                                "status": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/search": {
            "post": {
                "description": "Search the Podcast Index for podcasts matching the query string. Returns podcast metadata\nincluding titles, descriptions, feed URLs, and iTunes IDs. Results can be filtered by various\ncriteria such as value4value support, iTunes availability, and explicit content. Search uses\nthe Podcast Index API which indexes millions of podcasts from RSS feeds worldwide.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "search"
                ],
                "summary": "Search for podcasts by keyword",
                "parameters": [
                    {
                        "description": "Search parameters with query and optional filters",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/types.SearchRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Matching podcasts with metadata (feedId can be used with /podcasts/{id}/episodes)",
                        "schema": {
                            "$ref": "#/definitions/types.PodcastSearchResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request format or missing required query field",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Search service error or API communication failure",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Request timeout (search limited to 10 seconds)",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/trending": {
            "post": {
                "description": "Retrieve currently trending podcasts from Podcast Index based on recent activity and popularity.\nResults can be filtered by time period, categories, and language. Trending podcasts are determined\nby Podcast Index's algorithm which considers factors like new episodes, subscriber growth, and\nsocial media mentions. Use the returned podcast IDs (feedId) with /podcasts/{id}/episodes to get episodes.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "trending"
                ],
                "summary": "Get trending podcasts with optional filters",
                "parameters": [
                    {
                        "description": "Filter parameters (all optional - defaults to 10 podcasts from last 24 hours)",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/types.TrendingRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of trending podcasts with metadata",
                        "schema": {
                            "$ref": "#/definitions/types.TrendingPodcastsResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request format or parameter values",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Failed to fetch trending data from Podcast Index API",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Request timeout (limited to 10 seconds)",
                        "schema": {
                            "$ref": "#/definitions/types.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/health": {
            "get": {
                "description": "Get the health status of the API server and database connection",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "health"
                ],
                "summary": "Health check",
                "responses": {
                    "200": {
                        "description": "Server health status",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "database": {
                                    "type": "object"
                                },
                                "status": {
                                    "type": "string"
                                },
                                "timestamp": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "auth.UserInfo": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "role": {
                    "type": "string"
                }
            }
        },
        "clips.ClipResponse": {
            "description": "Complete information about an audio clip",
            "type": "object",
            "properties": {
                "created_at": {
                    "type": "string",
                    "example": "2025-09-25T16:36:45Z"
                },
                "duration": {
                    "type": "number",
                    "example": 15
                },
                "error_message": {
                    "type": "string",
                    "example": "failed to download source audio: HTTP 403"
                },
                "filename": {
                    "type": "string",
                    "example": "clip_052f3b9b-cc02-418c-a9ab-8f49534c01c8.wav"
                },
                "label": {
                    "type": "string",
                    "example": "advertisement"
                },
                "original_end_time": {
                    "type": "number",
                    "example": 45
                },
                "original_start_time": {
                    "type": "number",
                    "example": 30
                },
                "size_bytes": {
                    "type": "integer",
                    "example": 480078
                },
                "source_episode_url": {
                    "type": "string",
                    "example": "https://example.com/episode.mp3"
                },
                "status": {
                    "type": "string",
                    "example": "ready"
                },
                "updated_at": {
                    "type": "string",
                    "example": "2025-09-25T16:36:47Z"
                },
                "uuid": {
                    "type": "string",
                    "example": "052f3b9b-cc02-418c-a9ab-8f49534c01c8"
                }
            }
        },
        "clips.CreateClipRequest": {
            "description": "Request body for creating a new audio clip",
            "type": "object",
            "required": [
                "end_time",
                "label",
                "podcast_index_episode_id",
                "source_episode_url"
            ],
            "properties": {
                "end_time": {
                    "type": "number",
                    "example": 45
                },
                "label": {
                    "type": "string",
                    "minLength": 1,
                    "example": "advertisement"
                },
                "podcast_index_episode_id": {
                    "type": "integer",
                    "minimum": 1,
                    "example": 12345
                },
                "source_episode_url": {
                    "type": "string",
                    "example": "https://example.com/episode.mp3"
                },
                "start_time": {
                    "type": "number",
                    "minimum": 0,
                    "example": 30
                }
            }
        },
        "clips.UpdateLabelRequest": {
            "description": "Request body for updating a clip's label",
            "type": "object",
            "required": [
                "label"
            ],
            "properties": {
                "label": {
                    "type": "string",
                    "minLength": 1,
                    "example": "music"
                }
            }
        },
        "episodes.ClipResponse": {
            "description": "Audio clip time range for skipping or ML training",
            "type": "object",
            "properties": {
                "auto_labeled": {
                    "type": "boolean",
                    "example": true
                },
                "confidence": {
                    "type": "number",
                    "example": 0.85
                },
                "created_at": {
                    "type": "string",
                    "example": "2025-10-01T12:00:00Z"
                },
                "end_time": {
                    "type": "number",
                    "example": 45.2
                },
                "extracted": {
                    "type": "boolean",
                    "example": false
                },
                "label": {
                    "type": "string",
                    "example": "advertisement"
                },
                "start_time": {
                    "type": "number",
                    "example": 30.5
                },
                "user_confirmed": {
                    "type": "boolean",
                    "example": false
                },
                "uuid": {
                    "type": "string",
                    "example": "052f3b9b-cc02-418c-a9ab-8f49534c01c8"
                }
            }
        },
        "episodes.ClipsResponse": {
            "description": "Response containing clips for an episode",
            "type": "object",
            "properties": {
                "clips": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/episodes.ClipResponse"
                    }
                },
                "episode_id": {
                    "type": "integer",
                    "example": 123
                },
                "message": {
                    "description": "Human-readable message",
                    "type": "string"
                },
                "progress": {
                    "type": "integer",
                    "example": 45
                },
                "status": {
                    "description": "One of the Status constants above",
                    "type": "string"
                }
            }
        },
        "episodes.Review": {
            "type": "object",
            "properties": {
                "author": {
                    "type": "string",
                    "example": "User123"
                },
                "content": {
                    "type": "string",
                    "example": "Love this show..."
                },
                "id": {
                    "type": "string"
                },
                "rating": {
                    "type": "integer",
                    "example": 5
                },
                "title": {
                    "type": "string",
                    "example": "Best podcast ever!"
                },
                "updatedAt": {
                    "type": "string"
                },
                "voteCount": {
                    "type": "integer",
                    "example": 42
                },
                "voteSum": {
                    "type": "integer",
                    "example": 38
                }
            }
        },
        "episodes.ReviewData": {
            "type": "object",
            "properties": {
                "averageRating": {
                    "type": "number",
                    "example": 4.2
                },
                "mostHelpful": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/episodes.Review"
                    }
                },
                "ratingDistribution": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    }
                },
                "recentReviews": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/episodes.Review"
                    }
                },
                "totalCount": {
                    "type": "integer",
                    "example": 487
                }
            }
        },
        "episodes.ReviewsResponse": {
            "type": "object",
            "properties": {
                "cachedAt": {
                    "type": "string"
                },
                "episodeId": {
                    "type": "integer",
                    "example": 123456789
                },
                "itunesId": {
                    "type": "integer",
                    "example": 1535809341
                },
                "message": {
                    "type": "string"
                },
                "reviews": {
                    "$ref": "#/definitions/episodes.ReviewData"
                },
                "status": {
                    "type": "string",
                    "example": "success"
                }
            }
        },
        "models.EpisodeResponse": {
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "lang": {
                    "description": "Language parameter used",
                    "type": "string"
                },
                "max": {
                    "description": "Max results parameter used (string to match PodcastIndex API)",
                    "type": "string"
                },
                "notcat": {
                    "description": "Excluded categories",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "results": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/podcastindex.Episode"
                    }
                },
                "status": {
                    "type": "string"
                },
                "totalCount": {
                    "type": "integer"
                }
            }
        },
        "podcastindex.CategoriesResponse": {
            "type": "object",
            "properties": {
                "count": {
                    "type": "integer"
                },
                "description": {
                    "type": "string"
                },
                "feeds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/podcastindex.Category"
                    }
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "podcastindex.Category": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "podcastindex.Episode": {
            "type": "object",
            "properties": {
                "chaptersUrl": {
                    "type": "string"
                },
                "dateCrawled": {
                    "type": "integer"
                },
                "datePublished": {
                    "type": "integer"
                },
                "datePublishedPretty": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "duration": {
                    "type": "integer"
                },
                "enclosureLength": {
                    "type": "integer"
                },
                "enclosureType": {
                    "type": "string"
                },
                "enclosureUrl": {
                    "type": "string"
                },
                "episode": {
                    "type": "integer"
                },
                "episodeType": {
                    "type": "string"
                },
                "explicit": {
                    "type": "integer"
                },
                "feedDead": {
                    "type": "integer"
                },
                "feedDuplicateOf": {
                    "type": "integer"
                },
                "feedId": {
                    "type": "integer"
                },
                "feedImage": {
                    "type": "string"
                },
                "feedItunesId": {
                    "type": "integer"
                },
                "feedLanguage": {
                    "type": "string"
                },
                "guid": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "image": {
                    "type": "string"
                },
                "link": {
                    "type": "string"
                },
                "season": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                },
                "transcriptUrl": {
                    "type": "string"
                }
            }
        },
        "types.Episode": {
            "type": "object",
            "properties": {
                "audioUrl": {
                    "type": "string"
                },
                "chaptersUrl": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "duration": {
                    "description": "Seconds",
                    "type": "integer"
                },
                "episode": {
                    "description": "Episode number",
                    "type": "integer"
                },
                "id": {
                    "description": "Podcast Index Episode ID",
                    "type": "integer"
                },
                "image": {
                    "type": "string"
                },
                "link": {
                    "description": "Episode webpage URL",
                    "type": "string"
                },
                "podcastId": {
                    "description": "Podcast Index Podcast ID",
                    "type": "integer"
                },
                "publishedAt": {
                    "description": "Unix timestamp",
                    "type": "integer"
                },
                "season": {
                    "description": "Season number",
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                },
                "transcriptUrl": {
                    "type": "string"
                }
            }
        },
        "types.EpisodesResponse": {
            "type": "object",
            "properties": {
                "count": {
                    "description": "Number of results in this response",
                    "type": "integer"
                },
                "episodes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.Episode"
                    }
                },
                "message": {
                    "description": "Human-readable message",
                    "type": "string"
                },
                "offset": {
                    "type": "integer"
                },
                "status": {
                    "description": "One of the Status constants above",
                    "type": "string"
                },
                "total": {
                    "description": "Total available (if known)",
                    "type": "integer"
                }
            }
        },
        "types.ErrorResponse": {
            "type": "object",
            "properties": {
                "details": {
                    "description": "Additional error details"
                },
                "error": {
                    "description": "Error code/type",
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "types.JobStatusResponse": {
            "type": "object",
            "properties": {
                "episode_id": {
                    "description": "Episode ID",
                    "type": "integer"
                },
                "error": {
                    "description": "Error message (only for failed status)",
                    "type": "string"
                },
                "error_code": {
                    "description": "Specific error code like \"403\", \"timeout\", \"corrupt_file\" (only for failed jobs)",
                    "type": "string"
                },
                "error_details": {
                    "description": "Technical error details for debugging (only for failed jobs)",
                    "type": "string"
                },
                "error_type": {
                    "description": "Error type: \"download\", \"processing\", \"system\" (only for failed jobs)",
                    "type": "string"
                },
                "hint": {
                    "description": "Helpful hint for the client (e.g., \"Use retry=true parameter\")",
                    "type": "string"
                },
                "job_id": {
                    "description": "Job ID (optional)",
                    "type": "integer"
                },
                "max_retries": {
                    "description": "Maximum retry attempts (only for failed jobs)",
                    "type": "integer"
                },
                "message": {
                    "description": "Human-readable message",
                    "type": "string"
                },
                "progress": {
                    "description": "Progress 0-100",
                    "type": "integer"
                },
                "retried": {
                    "description": "True if this was a manual retry (only when applicable)",
                    "type": "boolean"
                },
                "retry_after": {
                    "description": "Seconds until retry (only for failed jobs)",
                    "type": "number"
                },
                "retry_count": {
                    "description": "Number of retries attempted (only for failed jobs)",
                    "type": "integer"
                },
                "status": {
                    "description": "Status: pending, processing, completed, failed, permanently_failed, not_found",
                    "type": "string"
                }
            }
        },
        "types.Podcast": {
            "type": "object",
            "properties": {
                "author": {
                    "type": "string"
                },
                "categories": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "description": {
                    "type": "string"
                },
                "episodeCount": {
                    "type": "integer"
                },
                "feedUrl": {
                    "type": "string"
                },
                "id": {
                    "description": "Podcast Index ID",
                    "type": "integer"
                },
                "image": {
                    "type": "string"
                },
                "itunesId": {
                    "type": "integer"
                },
                "language": {
                    "type": "string"
                },
                "lastUpdated": {
                    "description": "Unix timestamp",
                    "type": "integer"
                },
                "link": {
                    "description": "Podcast website URL",
                    "type": "string"
                },
                "title": {
                    "type": "string"
                }
            }
        },
        "types.PodcastSearchResponse": {
            "type": "object",
            "properties": {
                "count": {
                    "description": "Number of results in this response",
                    "type": "integer"
                },
                "message": {
                    "description": "Human-readable message",
                    "type": "string"
                },
                "offset": {
                    "type": "integer"
                },
                "podcasts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.Podcast"
                    }
                },
                "query": {
                    "type": "string"
                },
                "status": {
                    "description": "One of the Status constants above",
                    "type": "string"
                },
                "total": {
                    "description": "Total available results (if known)",
                    "type": "integer"
                }
            }
        },
        "types.SearchRequest": {
            "type": "object",
            "required": [
                "query"
            ],
            "properties": {
                "apOnly": {
                    "description": "Only return podcasts with iTunes ID",
                    "type": "boolean",
                    "example": false
                },
                "clean": {
                    "description": "Only return non-explicit content",
                    "type": "boolean",
                    "example": false
                },
                "fullText": {
                    "type": "boolean",
                    "example": false
                },
                "limit": {
                    "type": "integer",
                    "example": 10
                },
                "query": {
                    "type": "string",
                    "example": "technology"
                },
                "val": {
                    "description": "Filter by value block type (e.g., \"any\", \"lightning\")",
                    "type": "string",
                    "example": "any"
                }
            }
        },
        "types.SingleEpisodeResponse": {
            "type": "object",
            "properties": {
                "episode": {
                    "$ref": "#/definitions/types.Episode"
                },
                "message": {
                    "description": "Human-readable message",
                    "type": "string"
                },
                "status": {
                    "description": "One of the Status constants above",
                    "type": "string"
                }
            }
        },
        "types.TranscriptionData": {
            "type": "object",
            "properties": {
                "cached": {
                    "description": "Whether data is cached - optional for some responses",
                    "type": "boolean"
                },
                "duration": {
                    "description": "Duration in seconds",
                    "type": "number",
                    "example": 300.5
                },
                "episode_id": {
                    "description": "Episode ID (optional for some responses)",
                    "type": "integer"
                },
                "language": {
                    "description": "Detected or specified language",
                    "type": "string",
                    "example": "en"
                },
                "model": {
                    "description": "Model used for transcription",
                    "type": "string",
                    "example": "ggml-base.en.bin"
                },
                "source": {
                    "description": "\"fetched\" or \"generated\" - optional for some responses",
                    "type": "string"
                },
                "text": {
                    "description": "Full transcription text",
                    "type": "string",
                    "example": "This is the transcription..."
                }
            }
        },
        "types.TrendingPodcastsResponse": {
            "type": "object",
            "properties": {
                "count": {
                    "description": "Number of results in this response",
                    "type": "integer"
                },
                "message": {
                    "description": "Human-readable message",
                    "type": "string"
                },
                "podcasts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.Podcast"
                    }
                },
                "since": {
                    "description": "Hours back for trending calculation",
                    "type": "integer"
                },
                "status": {
                    "description": "One of the Status constants above",
                    "type": "string"
                }
            }
        },
        "types.TrendingRequest": {
            "type": "object",
            "properties": {
                "categories": {
                    "description": "Category names/IDs to filter",
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "example": [
                        "News",
                        "Technology"
                    ]
                },
                "fullText": {
                    "description": "Return full descriptions",
                    "type": "boolean",
                    "example": false
                },
                "lang": {
                    "description": "Language code",
                    "type": "string",
                    "maxLength": 10,
                    "example": "en"
                },
                "max": {
                    "type": "integer",
                    "maximum": 100,
                    "minimum": 1,
                    "example": 10
                },
                "since": {
                    "description": "Hours ago (max 30 days)",
                    "type": "integer",
                    "maximum": 720,
                    "minimum": 1,
                    "example": 24
                }
            }
        },
        "types.Waveform": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "type": "number"
                    }
                },
                "duration": {
                    "description": "Total duration in seconds",
                    "type": "number"
                },
                "episodeId": {
                    "type": "integer"
                },
                "id": {
                    "type": "string"
                },
                "sampleRate": {
                    "type": "integer"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "types.WaveformResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "description": "Human-readable message",
                    "type": "string"
                },
                "status": {
                    "description": "One of the Status constants above",
                    "type": "string"
                },
                "waveform": {
                    "$ref": "#/definitions/types.Waveform"
                }
            }
        }
    },
    "tags": [
        {
            "description": "Health check endpoints",
            "name": "health"
        },
        {
            "description": "API version information",
            "name": "version"
        },
        {
            "description": "Podcast search functionality",
            "name": "search"
        },
        {
            "description": "Episode management and playback",
            "name": "episodes"
        },
        {
            "description": "Trending podcast discovery",
            "name": "trending"
        },
        {
            "description": "Podcast management and synchronization",
            "name": "podcasts"
        },
        {
            "description": "Audio waveform generation and retrieval",
            "name": "waveform"
        },
        {
            "description": "ML training audio clips extraction and management",
            "name": "clips"
        }
    ]
}